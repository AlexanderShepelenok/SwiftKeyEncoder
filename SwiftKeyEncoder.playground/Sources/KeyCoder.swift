import Foundation

public class KeyCoder {
    private let saltSize: Int
    private let mask: [UInt8]
    private let keyEncoder: KeyEncoder
    private let keyDecoder: KeyDecoder

    private lazy var maxKeySize = mask.count

    /**
     - saltSize: Number of randomly-generated bytes added to the beginning and end of the encoded key
     */
    public init(saltSize: Int, mask: [UInt8]) {
        self.saltSize = saltSize
        self.mask = mask
        self.keyEncoder = KeyEncoder(saltSize: saltSize)
        self.keyDecoder = KeyDecoder(saltSize: saltSize)
    }

    // MARK: - Public methods

    public func printEncodedKey(_ key : String, named keyName: String) {
        let encodedBytes = encode(string: key)
        hexPrint(encodedBytes, keyName: keyName)
    }

    // MARK: - Internal methods

    internal func hexPrint(_ bytes: [UInt8], keyName: String) {
        let hexString = bytes.map { String(format:"%02x", $0) }
            .joined(separator: ", 0x")
        let output = output(forKeyName: keyName, hexString: hexString)
        print(output)
    }

    internal func encode(string: String) -> [UInt8] {
        assert(string.count <= maxKeySize,
               "Max key size is \(maxKeySize). Current key size is \(string.count)")
        return keyEncoder.encode(string: string, mask: mask)
    }

    internal func decode(bytes: [UInt8]) -> String {
        keyDecoder.decode(bytes: bytes, mask: mask)
    }

    internal func output(forKeyName keyName: String, hexString: String) -> String {
"""
ðŸ”‘ Encoding completed successfully.

You can copy the following output directly into your code:

var \(keyName) = [0x\(hexString)]
"""
    }
}
